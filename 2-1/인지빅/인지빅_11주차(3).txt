00:15 
이번 시간에는 이제 딥러닝 테스트 데이터를 한번 분석해보고요. 그리고 딥러닝 테스트 코드를 직접 한번 실행해보는 시간을 가져보도록 하겠습니다. 안내된 부재의 깃허브 페이지를 한번 먼저 접속을 해서 예제 데이터를 한번 받아보도록 할게요 다음 주소로 한번 들어가 보시면 빅터브 주소 여기 들어가 보시면 교재에서 제공하는 그런 빅터브 페이지로 들어오게 됩니다. 데이터셋에서 여기 첫 번째 있는 csv 파일을 클릭해보시면 다음과 같이 어떤 예제 데이터가 표시됩니다. 그러면 470라인인 것을 알 수 있죠. 

01:08 
이 데이터는 어떤 데이터냐면 폴란드 브로츠와프 의과대학에서 2013년 공개한 폐암 수술 환자의 수술 전 진단 데이터와 수술 후 생존 결과를 기록한 실제 의료기록 가상으로 만든 것이 아니고 실제 의료 기록 데이터라는 것을 알 수 있죠. 여기서 말씀드리는 행 하나 1번 행 또는 생명의 사람을 얘기하고요. 그래서 이런 속성 17개의 속성이 있고요. 그리고 이분이 생존했는지 폐암 수술 후에 생존했으면 1 생존하지 못했으면 0 마킹을 해놓은 거죠. 

01:52 
폐암수술환자의 생존율 생존했냐 못 했냐 폐암 수술 전에 어떤 데이터들 17개의 어떤 환자 데이터가 있고요. 또 수술 후에 생존을 했는지 못했는지를 기록한 데이터입니다. 그렇다면 17개의 속성은 예를 들면 환자가 수술 전에 환자의 어떤 데이터라고 했는데 예를 들어 종양의 유형 생활량 호흡 곤란 여부 고통 정도 기침 흡연 천식 여부 등 환자 상태를 조사해서 기록해 놓은 거예요. 그래서 마지막 17개의 어떤 첫 번째 환자는 이런 17개의 습성이 각각의 이런 정보가 있고요. 

02:48 
이럴 때 이 환자가 폐암 수술을 했고 여기까지 퇴암 수술을 했고 다음에 생존하셨는지 돌아가셨는지를 막힌 열여덟 번째 열은 막힌 후원 결이 되겠습니다. 그래서 이제 18번째 열이 0이면 사망 1이면 수술 후의 생존 이렇게 보면 되겠죠. 이제 우리가 이거를 활용하기 위해서 데이터를 이렇게 한번 다운을 받아봐야 되는데 어떻게 다운받느냐 보시면 카피 로우 콘텐츠 이렇게 카피 로우 콘텐츠를 해서 붙여넣기는 해도 됩니다. 새로우 콘터치 한 다음에 저기 메모장에다 붙여놓고 해도 되죠. 

03:46 
그러면 로우를 클릭하시면 이렇게 뜨죠 그냥 뭐 csv 파일 자체를 웹에서 여는 형태가 되죠. 이렇게 그래서 csv라는 거는 세퍼레이티드 밸류스라고 해서 콤마로 구분된 값들이에요. 여기서 엔터죠 그래서 콤마와 엔터로 이렇게 구분을 할 수 있죠. 방금 전에 우리 그런 470명의 데이터들은 가장 간단하게 데이터를 표현해 주는 빈더더기 없이 그런 포맷이라고 보시면 돼요. 이거를 아까처럼 카피해서 전체를 여기 마우스 한번 클릭하시고 컨트롤 a를 하면 전체 선택이 되죠. 그다음에 컨트롤 c 한 다음에 메모장에 붙여놓고 저장을 여기 이름으로 하시면 되죠. 

04:41 
똑같이 하셔도 되고 아니면 현재 이 페이지에서 우측 클릭을 하신 다음에 다른 노동으로 저장 이렇게 하셔도 되죠. 바로 이렇게 저장이 되죠. 근데 우리가 이제 저장 위치를 조금 한번 생각을 해봐야 됩니다. 바로 다른 내가 임의의 장소에 저장을 한 다음에 나중에 코드에서 그거를 다 공동 지정을 해줘도 되죠. 당연히 그렇게 관리하는 건 반영이 되고요. 가장 간단하게 실행을 할 수 있는 방법은 우리가 프로젝트 있었죠. 지난 시간에 설치해 놓은 프로젝트 저는 여기 텍스트였고 사용자가 테스트해서 했었죠. 거기서 보시면 파이찬 프로젝트라고 해서 테스트 1이 있었습니다. 그래서 여기에 이제 모든 파일들이 이제 여기 들어갈 텐데요. 

05:35 
파일 형식은 이렇게 모든 파일 한번 보시면 어제 했던 여기 파이썬 파일도 있죠. 저장 저장을 csv 함마 세퍼레이티드 밸류스 파일로 저장을 하려고 합니다. 그래서 저장 클릭하시면 저장이 되겠죠. 그래서 한번 폴더를 우리가 가보면 들어가서 보면 사용자 c 드라이브 사용자 호스트 파이참 프로젝트 그러면 여기 들어있죠. 엑셀이 아마 깔린 학생들은 깔린 분들은 여기 엑셀에서 열 수 있는 그런 표시가 떠요 csv 파일 클릭을 해보시면 엑셀에서도 한번 확인할 수 있어요. 대응에서 알 수 있죠. 페이스 베이파이어는 엑셀에서도 열립니다. 

06:30 
그리고 뭐 엑셀에서 난 열기 싫다 메모장에서 열겠다. 그러면 터치 열리죠 그렇게 이제 잘 다운로드가 된 것을 알 수 있습니다. 다음으로는 이제 우리가 코드 예제 코드를 한번 다운로드 받아볼 거예요. 우리가 처음부터 뭔가 파이썬 텐서플로우 코딩을 하는 것은 조금 무리가 있기 때문에 한번 폐암 수술 환자의 생존률을 예측하는 코드를 다운받아서 살펴보도록 하겠습니다. 역시 이제 교재에서 이것도 제공을 하고 있는데요. 한번 따라볼게요 주소를 클릭하시면 라이퍼스트 딥러닝 점프 타입 이렇게 되어 있죠. 

07:30 
이 코드가 바로 우리가 수술 환자의 데이터 구조들이고 판단하는 그런 해양 수술 환자의 생성력 예측하는 코드가 되겠습니다. 이 코드는 그러면 어떻게 하느냐 역시나 마찬가지로 카피한 다음에 해도 되고요. 로우로 들어가서 그래서 저장을 해도 됩니다. 다른 저장 방법이 많이 있죠. 코드가 있기 때문에 여기서 이것도 이렇게 긁어서 컨트롤 시 컨트롤을 해도 되고요. 여러 가지 방법으로 이 코드를 사용하면 됩니다. 그래서 우리는 이 코드를 먼저 한번 코드까지 이렇게 봤기 때문에 한번 우리가 코랩 환경에서 먼저 한번 해볼게요 어제 했었죠. 

08:24 
들어가시면 새 노트로 작성이 되었고 제목은 뭐라고 할까요? 퍼스트 여기다가 이제 붙여넣기를 하면 되죠. 여기다 붙여넣기도 하면 돼요. 아까 전에 있었던 코드 이거를 클릭 한번 하셔야 컨트롤 a 다 되는 그래서 이렇게 해줘도 되고요. 아니면 여기서 보시면 로우 카피 로우 컨센스를 할 때 또는 자동으로 클릭 한번 해피가 됩니다. 알파이썬으로 와서 컨트롤 도입을 하면 다 들어가겠죠. 넣어서 실행을 해보면 돼요. 

09:19 
이제 한번 해보면 동작이 안 될 거예요. 처음에는 연결한다고 좀 시간이 걸리죠 여기 초기화하고요. 소스를 넣어야 할당을 받아야 되니까. 연결도 하고 이제 돌리기 시작합니다. 이제 에러가 났죠. 여기서 에러는 이제 우리가 여기 친절하게 빨간 위쪽에 그어주죠 데이터를 우리는 지금 아까 다운로드를 pc에다 받았어요. pc에다 받았고 여기 여기는 지금 우리가 클라우드 환경에서 돌리고 있잖아요. 그래서 여기 pc에 받아놓고 그런 어떤 중간 과정이 생략이 된 거죠. 데이터는 pc에 받았는데 우리는 지금 실행을 코랩이니까. 구글 클라우드에서 실행을 하고 있죠. 그러니까 지금 아 이 파일이 없습니다. 라는 뜻이에요. 

10:19 
데이터를 불러들이는데 그래서 에러가 났습니다. 못 불러들였다는 거죠. 그래서 이 과정을 좀 추가를 해줘야 돼요. 그래서 여기서 이제 코랩에서 쓰기 위해서는 여기 제공되는 파일에서 추가를 해줘야 됩니다. 먼저 그걸 코랩에서 제공하는 어떤 함수를 써야 돼요. 코랩에서 파일을 받아들일 수 있도록 그래서 보통 그런 함수를 불러오는 거는 이게 이제 함수들을 불러오는 건데 왜 앞부분을 많이 쓰죠 중간에 쓰면은 어 여기다 쓰면은 만약 여기다가 만약에 이런 홍수를 불고 오면 이 위치에다가 그 위치에다가 쓰면 만약에 그 함수를 앞부분에서 콜을 한다면, 콜이 안 되겠죠. 

11:15 
그래서 이런 함수를 불러오는 애들은 앞부분에다가 그걸 써줍니다. 그래서 이걸 함수를 불러오는 형태 임포트 이 형태는 얘기했었죠. 함수를 불러오는데 앞으로 나는 tf라고 콜을 할 거야. 그리고 프롬하고 임폴트도 이렇게 불러오는 것도 있죠. 이거는 후반부에 코드를 조금 설명하는 과정에서 이렇게 한 다음에 이제 파일 업로드를 해야 돼요. 그래서 데이터를 그냥 불러들이는 게 아니고 클라우드 형태 환경으로 업로드를 해야 되죠. 여기서 파일즈라는 함수를 쓰는 거예요. 지금 임포트 파일즈라고 했죠. 

12:13 
그다음에 업로드 파일지 아니면 업로드 함수를 불러옵니다. 그러면 뭔가 업로드하세요. 라는 게 뜨겠죠. 그래서 어 여기 그러면 이제 뭔가 이제 우리가 업로드 작업을 하게 되면 파일을 첨부하거나 이런 작업이 있겠죠. 그다음에는 첨부된 파일을 데이터셋이라는 곳에 넣어야겠죠. 이렇게 코드가 쓰입니다. 여기서는 우리가 바로 이 파일을 업로드할 거기 때문에 이렇게 쓰시면 돼요. 이렇게 하면은 이렇게 하고 실행을 해보죠. 그러면 파일을 선택하세요라고 얘기해요. 여기서 지금 화살표 보이죠. 열려있다. 파일 선택하세요. 

13:08 
그러면 조금 전에 우리가 다운로드 받았던 그 파일을 선택한 다음에 열기를 합니다. 그러면 파일이 업로드가 됐고 조작을 하겠죠. 그래서 파일 이름이 다르면 안 되겠죠. 업로드를 어딘가 구글 클러드의 어떤 데이터 저장소로 업로드를 하고 여기서는 그걸 이제 불러오는 거죠. 우리가 업로드한 것을 불러줘요 그래서 그다음에 쭉 진행이 돼서 이렇게 동작을 한 것을 알 수 있어요. 그다음에 동작을 한 거고, 최종 어큐러시는 84.68%로 예측을 했다. 이렇게 보시면 되죠. 좀 더 구체적인 건 코드설명에서 이렇게 코랩에서 이제 돌리는 것을 했고요. 

14:03 
우리가 다음으로는 파이참 환경에서 한번 해볼게요 파이참을 켜면 이렇게 나오죠. 지난 시간에 했던 퍼스트 파이썬이라는 파일입니다. 여기서 그대로 한번 이걸 지우고 한번 해볼게요 여기서도 마찬가지로 우리가 컨트롤 v를 하면 지금 남아 있었죠. 아까 컨트롤 c는 코드가 바로 컨트롤 v를 하면 현재 코드가 여기 바로 쓰여집니다. 그리고 파이썬 콘솔도 우리가 한번 했었죠. 이렇게 이제 불러왔습니다. 

14:47 
여기서도 바로 실행을 하면 그런 문제가 생기죠 어떤 문제가 생기느냐 지금 우리가 데이터를 불러오는 문제가 생깁니다. 한번 그대로 한번 해볼게요 그러면 에러가 뜨겠죠. 에러가 뜹니다. 라인 10 19에서 클릭을 하시면 폰으로 가서 이 부분에서 에러가 났습니다. 낫 파운드라고 되어 있죠. 없다. 그래서 여기서는 어떻게 하느냐 우리가 파일을 폴더를 보시면 퍼스트 파이썬 파일하고 데이터 파일하고 같은 위치에 있죠. 같은 폴더에 들어있죠. 

15:46 
그렇기 때문에 바로 이렇게 불러주면 돼요. csv8을 로드합니다. 이렇게 해놓고, 위치 클릭 런 해보면 28% 나온 결과를 볼 수 있죠. 그래서 똑같다 여기서도 코랩이나 파이창이나 돌리는 건 똑같다고 보시면 돼요. 그리고 이제 우리가 콘솔 얘기를 했었죠. 파이썬 콘솔에서 돌리는 것 아까 전에 런 그냥 이제 여기서 돌리면 프로세스가 끝나요? 뭔가 내가 여기서 뭔가 더 해볼 수가 없어요. 콘솔에서 한번 돌려보죠. 콘솔에서도 여기서 이제 이 프롬프트에서 그걸 보인 다음에 그냥 데이터 쳐도 돌아 들어가죠 여기서는 csv 파일이 없는 제가 복사한 이렇게 조정을 해야 됩니다. 

16:50 
그런 다음에 인터를 치면 돌아가겠죠. 파이썬 콘솔에서 실행시키면 이렇게 지금 현재 데이터셋은 뭐가 들어있고 x에는 어떤 값이 들어있고 이런 게 다 보여요. 그래서 x 데이터셋 여기서 더 해볼 수 있죠. 이제 멈춘 상태죠 종료하고 완전 플러스가 끝난 게 아니고 추가로 더 해볼 수 있는 거예요. x라는 거에는 이런 게 들어있구나 y에는 어떤 게 들어있을까? y는 이렇게 레이블링 되는 데이터가 들어있구나 이런 걸 해볼 수 있다는 거죠. 그래서 이렇게 콘솔의 역할이 그런 거고요. 그리고 우리가 gpu 사용은 현재 안 하고 있죠. 

17:47 
gpu세팅은 파이참에서 gpu 세팅하는 것 그러니까 내 pc에서 gpu를 세팅하는 거는 한번 찾아보시기 바라는 그런 과정이 잘 안내되어 있기 때문에 인터넷에 관심 있는 분들을 한번 찾아보시면 되겠습니다. 그렇다면 여기서 이제 우리가 프로젝트를 지난 시간에 프로젝트 얘기 나눴는데 현재 우리가 프로젝트를 하나를 했죠. 다음 프로젝트를 하면 어떻게 될까요라는 것을 한번 간단히 클로즈 프로젝트를 하면 원래대로 이렇게 돌아갑니다. 프로젝트 하나 있죠. 테스트에 클릭하면 아까 거기로 돌아가고 프로젝트는 이렇게 들어옵니다. 그래서 나는 새로운 걸 한번 해볼 거예요. 이 프로젝트 그래서 두 번째 텍스트 2라는 프로젝트를 내가 만들 겁니다. 

18:44 
그래서 저번처럼 여기서 이렇게 활성 버튼 선택해서 제너레이션 해도 돼요. 플레이트 해도 되는데 근데 봤더니, 테스트 1하고 내가 환경이 같다 텐서플로라든가 여러 개 작업을 해놨죠 텐서플로 설치를 이미 해놨죠 테스트1 얘기입니다. 테스트2에서도 테스트1에서 사용한 환경을 그대로 써도 됩니다. 그러면 지금 테스트1이 있죠. 그래서 3.8 테스트1을 내가 쓰겠다. 저번에 여기 mak of aleable 2 올 프로젝티스 클릭을 해놨기 때문에 보이는 거예요. 스트레이트를 하면 테스트2라는 프로젝트가 생성됩니다. 그래서 과연 환경이 잘 불러져 왔는지를 보려면 테스트런스 있죠. 

19:38 
가시고 프로젝트 테스트2의 인터프리터란을 보시면 현재 내가 파이썬 인터프리터 환경을 가져온 거는 파이썬 3.8 기반의 테스트 1에서 쓰는 걸 내가 그대로 가져왔습니다. 그러다 보니까 여기보시면 사회사 블록 그대로 설치되어 있죠. 나는 여기서 설치한 적이 없지만, 테스트1에서 계속 설치를 한 거예요. 그래서 그 테스트 1 현재의 이제 빌드업들 설치된 고 키들이 그대로 들고 옵니다. 이렇게 안 하면 다 처음부터도 아까 텐서플로 설치한 걸 설치해야겠죠. 지금은 간단하지만 예를 들어 설치한 패키지가 뭐 20개예요. 그걸 다시 처음부터 다 설치를 해야 되는데 아까처럼 바로 그냥 가져오기를 환경을 가져와 버리면 좀 수월하다는 거죠. 지프로드 프로젝트한 다음에 우리가 원래 했던 텍스토리1으로 들어가겠습니다. 

20:39 
이렇게 이제 파이썬 테스트 코드를 코랩 환경하고 우리가 파이쳐 환경에서 다 테스트를 해봤습니다. 그래서 코드 설명을 한번 드리도록 할게요 코드 설명은 파이쳐 환경에서 한번 설명 드리도록 하겠습니다. 먼저 이제 프롬 텐서플로우 케라스 모델스 해서 시퀀셜이라는 걸 불러왔어요. 프롬이라는 것의 의미는 먼저 프롬을 안 해도 돼요. 프롬 안 해도 되고 똑같이 어떻게 썼느냐 첫 번째 줄 일곱 번째 줄하고 여섯 번째 줄은 현재 같은 거예요. 제가 한번 써볼게요 임포트하고 텐서 로우 점프라스 이렇게 불러오는 거랑 같은 거예요. 

21:44 
이렇게 했고 여기서 이제 주석 처리하는 거는 컨트롤하고 여기 물음표 키보드에 오른쪽 시프트 바로 왼쪽에 있는 슬래시 그걸 해보면 이렇게 샷이 앞에 붙어요. 한 번 더 하면 없어지고 그래서 이렇게 불러오면 여기서 시퀀셜을 불러온다는 것은 텐서플로우에 있는 텐서플로우 안에 보라스 안에 모델스 안에 시퀀셜에 있는 함수를 쓰겠다는 거죠. 그냥 이렇게 쭉 불러오면 불러와지지 않죠 임포트를 뭘 하는지를 정확히 지정해 줘야 돼요. 그래서 임포트 다음에는 하나가 와야 돼요. 

22:30 
쭉 쓰면 안 되고 이런 의미긴 한데 그러면 우리가 프롬 펜서클로 이렇게 여기에 있는 이렇게 해서 이렇게 이렇게 임프트를 하는 건 틀렸고 그렇기 때문에 이런 어떤 아랫줄에 쓴 의미를 위처럼 쓰는 거고, 밑줄처럼 내가 정확히 임포트하는 거는 시퀀셜이라는 거고, 그거는 텐서클로 데아스 레드레스 안에 시퀀셜이 있다. 그걸 폰이라고 처리를 해줍니다. 영어로 생각하시면 돼요. 여기 예를 들면 시퀀션 함수는 포트 하겠다. 임포트 했다면, 다음부터는 이제 시퀀셜 그대로 쓰면 되죠. 함수를 그래서 아래 보면 28번째 줄에 보면 시퀀셜이라는 함수를 그대로 씁니다. 이게 어디 있는지 여기서 지정해 줬기 때문에 일곱 번째 줄에서 지정해 줬기 때문에 바로 쓸 수 있는 것이죠. 

23:31 
그리고 이제 이어서 얘기를 해보면 그렇다면 이렇게 이걸 쓰지 않는다. 그러면 어떻게 해야 될까요? 시퀀셜이 어디 있는지 지금 모른다고 빨간 줄이 쳐졌죠 그러면 텐서플로 안에 tf라고 쓰기로 했죠. 안에 있는 피페라스 안에 있는 로우데스 안에 있는 시퀀셜입니다. 이렇게 지정을 해줘요 컨스플로우라는 걸 우리가 불러왔기 때문에 스모레스 시퀀셜입니다. 이렇게 하면 런을 한번 해보면 그래도 되죠. 그래서 이렇게 해도 되죠. 근데 할 때마다 이거를 여기에 붙여줘야 돼요. 이만큼 귀찮아요. 그러면 그래서 우리가 이거를 이렇게 시퀀셜이라는 걸 그대로 위에서 임포트를 해주고 바로 밑에서 쓰는 거죠. 프롬 임포트 이렇게 불러오는 것도 있다. 

24:28 
임포트 한 다음에 lgmp 간단하게 쓰는 것도 있죠. 많이 반복되는 애들은 이렇게 앞으로 np로만 쓰겠다. 넘파일을 포트로 쓰겠다. 하는 거죠. 그다음에 이제 랜덤 시드를 이제 그 시드를 이렇게 지정을 해줬어요. 랜덤 시드긴 한데 숫자가 랜덤하게 생성되는 거긴 한데 시드 자체를 내가 여기서 3 이렇게 됨으로써 매번 같은 값을 뽑아냅니다. 랜덤하게 뽑긴 하는데 매번 같은 값을 보내고 그러면 한번 이런 게 있다. 생각해 보시면 돼요. 그래서 매번 실행하면 어큐러시가 작게 나온다 근데 이거를 안 하면 아주 미세하게 바뀌어요. 

25:19 
그 이유는 그레이트랑 예를 들어 바이어스 초기화를 랜덤하게 하는데 랜덤하게 하는 초기값이 조금씩 바뀌기 때문에 결과도 조금씩 조금씩 흔들리게 되어 있습니다. 전체적인 경향은 같지만 통계를 내면 일정하겠지만, 외부의 순간에 어떤 결과는 조금씩 바뀔 수 있다. 그래서 대부분 우리가 사실은 해도 되고 안 해도 돼요. 그래서 이제 다음으로, 우리가 데이터를 불러들였죠 이런 데이터를 불러들였고 이 코드는 이제 x는 우리가 불러들인 데이터셋 데이터셋이라는 이걸 이제 넘파이로 굴러들였기 때문에 어떤 넘파이의 어떠한 데이터 스트럭처가 되겠죠. 이 데이터셋에 있는 여기 보시면 행렬로 되어 들어왔어요. 지금 여기가 470 행에 18열이 있는데, 그런 어떤 행렬이라고 보시면 돼요. 

26:15 
거기에 콤마로 구분합니다. 왼쪽의 행입니다. 이 땡땡을 한 거는 모든 행을 의미하죠. 데이터셋에 있는 모든 행과 그리고 0부터 0 열의 숫자의 카운트는 0부터 시작해요. 0부터 카운트에서 여기 17번째 10까지라고 표현을 했는데 이렇게 되면 맨 마지막 열일곱 번째 행은 뜹니다. 여기서 보시면 0부터 17까지는 총 18개죠 근데 이렇게 표현을 하면 0번째 10부터 0부터 16번째 열 총 그러니까 열의 개수는 17개를 내가 가져오겠다는 거죠. 

27:13 
17은 들어가지 않습니다. 그래서 그거를 내가 x라고 하겠다. 즉 470명의 속성 데이터를 내가 가져오게 되는 것이고. 해는 4710이고 y는 17번 모든 사람의 17번째 열만 가져오겠다. 010101 값만 y에 하겠다. 가져오겠다라는 것이죠. 그래서 이제 딥러닝 구조를 결정을 하게 되는데 여기서 모델하고 시퀀셜이라는 걸 아까 불러왔었죠. 우리가 신경망은 순차적으로 우리가 구성을 하겠다라는 겁니다. 모델이라는 거 안에 모델에서 이제 추가를 합니다. 

28:12 
그런 논스 폴리 커넥티드 레이어 하나를 추가를 하겠다. 노드의 개수는 30이고 입력 불량자는 17개의 노드가 입력이 되고 이렇게 30개의 어떤 다음 레이어에 30개의 노드로 이루어진 히든 레이어로 연결이 되겠죠. 그때 사용되는 액티베이션 함수가 되겠습니다. 그래서 이게 또 이어집니다. 계속 시퀀셜하게 추가하는 거예요. 제가 만드는 모델 안에 계속 추가를 하는 거죠. 이어서 하나짜리 노드가 하나인 레이어를 붙이겠습니다. 신경 레이어죠 그래서 인플레이어 17개 노드로 이루어진 인플레이어 그리고 30개의 노드로 이루어진 스킬 레이어 1개의 노드로 이루어진 아트 레이어로 이루어진 어떤 리얼 데스터가 있어요. 스피레이션을 시그모이드로 뒀습니다. 

29:10 
이렇게 이제 내가 모델을 구성을 했어요. 우리가 그 맨날 그림으로만 그리던 신경망을 여기 모델이라는 모델로 구성을 한 거죠. 그래서 우리가 구성한 모델을 컴파일을 합니다. 컴파일의 원리는 어떤 로스를 우리가 지정해준 로스를 최소화하도록 뭔가 최적화를 한다는 거예요. 즉 웨이트와 바이스를 업데이트하세요. 라는 겁니다. 이게 다 함수로 구성되어 있기 때문에 사실 이 안에서 팩트로프로게이션이 일어나는 거죠. loss를 최소화하도록 matrix를 팩트로프로게이션 알고리즘으로 업데이트하겠다. 그때 옵티마이저는 다음 옵티마이저를 쓰겠다. 

29:58 
그다음에 우리가 x와 y 가지고 한번 어플러시를 결정해 봐야겠죠. 그래서 x와 y를 가지고 epok을 x를 두고 g사이즈는 10으로 두고 시행을 해보겠다. 라는 여기서는 이제 속성 데이터와 레이블 데이터 정답 데이터를 가지고 시행해 보세요라는 뜻이에요. 이번에는 우리가 모델 컴파일 어떻게 우리가 이 모델을 데이터바이스 업데이트할 건지를 다 결정한 다음에 실제 데이터를 넣고 돌려보는 거죠. 이걸 쭉 돌아가는 거죠. 그래서 마지막으로, epok이라는 거는 우리가 총 470명의 데이터가 있었죠. 

30:53 
먼저 배치사이즈는 470명을 한 번에 우리가 최적화를 하게 되면 좀 양이 많죠 모든 470명을 다 만족하도록 데이트를 조금씩 업데이트하는 부담스럽죠 그래서 10명씩 보겠다는 거예요. 데이터를 10개씩 보겠다. 엣지사이즈 그리고 우리가 앱톡은 총 100번 돌겠다. 즉 470명의 데이터를 다 가지고 다 써서 웨이트 바이스를 업데이트한 거를 무한 네트워크라고 하고요. 그거를 100번을 반복하겠다는 거죠. 총 데이터를 100번을 반복해서 사용을 해서 웨이트 바이러스를 업데이트하겠다. 그래서 여기 보시면 결과를 보시면 우리가 한 번의 epok에서 한 번의 epok이면 데이터 하나죠. 

31:46 
그게 첫 번째 에폭에서 47이라는 거는 우리가 배치 사이즈를 10으로 했기 때문에 47번이 돌아야 10명씩 우리가 웨이트를 업데이트하기 때문에 47번이 지나면 전체 데이터를 한번 쓰는 거죠. 1 에프워크 17 1번 나왔다. 그리고 두 번째 네트워크도 이렇게 되는 거죠. 그래서 470명 데이터를 epoc1에서 한번 다 쓰고 x2에서도 다시 쓰고 이렇게 해서 100번을 쓴다는 거죠. 하나의 epoc1에서는 우리가 배치 사이즈를 10으로 지정했기 때문에 10명씩 10명씩 끊어서 총 47번이 돌아가는 거죠. 이렇게 이해를 하시면 되겠습니다. 여기서는 간략한 설명이기 때문에 여러분들이 여기서 바로 이해를 해서 뭔가 해야겠다. 

32:39 
이런 게 아니고 우리가 추후에 이어지는 강의에서 이런 거를 좀 더 깊이 있게 다른 예제들로 설명할 거기 때문에 이런 흐름으로 동작이 되는구나. 정도로 파악을 해 주시면 네 그래서 오늘은 우리와 함께 테스트 데이터를 한번 분석해 봤고요. 간단하게 테스트 코드를 코렉하고 파헤쳐 환경에서 실행을 해봤습니다. 오늘 강의는 여기까지입니다. 집중해서 수강해 주셔서 감사합니다. 해당 영상에 사용된 자료 출처는 출처 목록 11주 차에서 다운로드 가능합니다. 

