#include <WiFi.h>          // ESP32 Wi-Fi 라이브러리
#include <ThingSpeak.h>    // ThingSpeak 클라우드 플랫폼 통신 라이브러리
#include <Servo.h>         // 서보 모터 제어 라이브러리
#include "HX711.h"         // 로드셀 앰프 HX711 라이브러리
#include <MFRC522.h>       // RFID 리더 RC522 라이브러리
#include <SPI.h>           // RC522는 SPI 통신을 사용하므로 SPI 라이브러리 포함
#include <Ultrasonic.h>    // 초음파 센서 라이브러리 추가

// ==== Wi-Fi 설정 ====
const char* ssid = "본인의_와이파이_SSID";        // 접속할 Wi-Fi 네트워크 이름
const char* password = "본인의_와이파이_비밀번호";  // 접속할 Wi-Fi 비밀번호

// ==== ThingSpeak 설정 ====
unsigned long myChannelNumber = 0; // 본인의_채널_번호; // ThingSpeak 채널 ID (숫자)
const char* myWriteAPIKey = "본인의_쓰기_API_키";     // ThingSpeak 채널 쓰기 API 키 (문자열)

// ThingSpeak 필드 번호 정의
const int TS_FIELD_RFID = 1;
const int TS_FIELD_WEIGHT = 2;

WiFiClient client;

// ==== 핀 정의 ====
// 모터 제어 핀 (L9110S)
const int MOTOR_LEFT_IA = 13;
const int MOTOR_LEFT_IB = 12;
const int MOTOR_RIGHT_IA = 14;
const int MOTOR_RIGHT_IB = 27;

// 라인 센서 핀
const int LINE_SENSOR_LEFT = 34;  // ADC1 핀 권장
const int LINE_SENSOR_RIGHT = 35; // ADC1 핀 권장

// 초음파 센서 핀
const int ULTRASONIC_TRIG_PIN = 17;
const int ULTRASONIC_ECHO_PIN = 18;
Ultrasonic ultrasonic(ULTRASONIC_TRIG_PIN, ULTRASONIC_ECHO_PIN);

// 서보 모터 핀
const int SERVO_PIN = 16;

// HX711 로드셀 앰프 핀
const int HX711_DOUT = 4;
const int HX711_SCK = 2;

// MFRC522 RFID 리더 핀
const int MFRC522_SS = 5;
const int MFRC522_RST = 22;

// ==== 센서 및 동작 설정 ====
int line_threshold = 500;
int obstacle_distance_threshold = 30; // cm
int lid_closed_angle = 0;
int lid_open_angle = 90;
float calibration_factor = -22000; // 실제 보정 필수

// 타이머 변수
unsigned long lid_open_timer = 0;
const unsigned long LID_OPEN_DURATION = 5000; // 5초
unsigned long state_timer = 0;
const unsigned long WEIGHT_STABILIZE_DURATION = 2000; // 2초

// ==== 복귀 조건 및 배터리 측정 설정 ====
const float MAX_TRASH_WEIGHT_THRESHOLD = 1000.0; // g, 실제 환경에 맞게 조정
const int BATTERY_VOLTAGE_PIN = 33; // ADC1 핀 권장, 실제 연결 핀으로 변경
// 전압 분배 저항값
const float R1_VALUE = 18000.0; // 18k옴
const float R2_VALUE = 10000.0; // 10k옴
// 배터리 부족 ADC 값 임계값 (6.2V 기준 -> ADC핀 약 2.214V -> ADC 값 약 2747)
const int LOW_BATTERY_ADC_THRESHOLD = 2747; // 실제 테스트 후 미세 조정 필요

// 무게 저장 변수
float initial_weight = 0.0;
float final_weight = 0.0;
float trash_weight = 0.0;

// ==== 상태 머신 변수 ====
enum SystemState {
  STATE_LINE_FOLLOWING,
  STATE_STOPPED_OBSTACLE_DETECTED,
  STATE_STOPPED_WAITING_RFID, // 현재 직접 사용되진 않으나 확장성 위해 유지
  STATE_RFID_DETECTED,
  STATE_MEASURING_WEIGHT_BEFORE,
  STATE_OPENING_LID,
  STATE_LID_OPEN_WAITING,
  STATE_CLOSING_LID,
  STATE_MEASURING_WEIGHT_AFTER,
  STATE_CALCULATING_AND_SENDING,
  STATE_RESUMING_MOVEMENT,
  STATE_GOING_HOME_TRASH_FULL,
  STATE_GOING_HOME_LOW_BATTERY,
  STATE_AT_HOME
};
SystemState currentState = STATE_LINE_FOLLOWING;

// ==== 전역 객체 생성 ====
Servo lidServo;
HX711 scale;
MFRC522 mfrc522(MFRC522_SS, MFRC522_RST);
String current_rfid_uid_str = "";
byte current_rfid_uid_bytes[MFRC522::MAX_LEN];
byte current_rfid_uid_size = 0;

// ==== 함수 선언 ====
void stopMotors();
void moveForward(int speed);
void turnLeft(int speed);
void turnRight(int speed);
void updateLineFollowing(int left_sensor_val, int right_sensor_val);
void openLid();
void closeLid();
float readStableWeight();
void connectWiFi();
bool readRFID();
unsigned long getRFIDasULong(byte* uid, byte uidSize);
void transitionTo(SystemState nextState);
long measureDistance();
bool isBatteryLow();

// ==== 초기 설정 함수 (setup) ====
void setup() {
  Serial.begin(115200);
  delay(100);
  Serial.println("스마트 쓰레기통 라인 트레이서 시작 중...");

  pinMode(MOTOR_LEFT_IA, OUTPUT);
  pinMode(MOTOR_LEFT_IB, OUTPUT);
  pinMode(MOTOR_RIGHT_IA, OUTPUT);
  pinMode(MOTOR_RIGHT_IB, OUTPUT);
  stopMotors();

  pinMode(LINE_SENSOR_LEFT, INPUT);
  pinMode(LINE_SENSOR_RIGHT, INPUT);

  pinMode(BATTERY_VOLTAGE_PIN, INPUT);
  // ADC 감쇠 설정 (0-3.3V 범위 측정을 위해 11dB 권장)
  // 아날로그 핀 번호가 아닌 ADC 채널 번호로 설정해야 할 수 있음 (핀과 채널 매핑 확인 필요)
  // 예: adc1_config_channel_atten(ADC1_CHANNEL_5, ADC_ATTEN_DB_11); // GPIO33이 ADC1_CHANNEL_5일 경우
  // 간단하게는 analogRead 전에 analogSetPinAttenuation(BATTERY_VOLTAGE_PIN, ADC_11db); 호출
  // 여기서는 isBatteryLow() 함수 내에서 처리하거나, setup에서 ADC 전체 설정으로 반영

  Serial.println("초음파 센서 초기화 중...");
  // Ultrasonic 라이브러리가 내부적으로 pinMode를 처리하므로 별도 호출 불필요할 수 있음
  // pinMode(ULTRASONIC_TRIG_PIN, OUTPUT);
  // pinMode(ULTRASONIC_ECHO_PIN, INPUT);
  Serial.println("초음파 센서 준비 완료.");

  lidServo.attach(SERVO_PIN);
  closeLid();

  Serial.println("HX711 초기화 중...");
  scale.begin(HX711_DOUT, HX711_SCK);
  scale.set_scale(calibration_factor);
  scale.tare();
  Serial.println("HX711 준비 완료. 0점 조정됨.");

  Serial.println("MFRC522 초기화 중...");
  SPI.begin();
  mfrc522.PCD_Init();
  Serial.println("MFRC522 준비 완료. RFID 카드를 스캔하세요.");

  connectWiFi();
  ThingSpeak.begin(client);

  transitionTo(STATE_LINE_FOLLOWING);
}

// ==== 메인 루프 함수 (loop) ====
void loop() {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("WiFi 연결 끊김. 재연결 시도...");
    connectWiFi();
  }

  // 배터리 상태 확인 (특정 중요 작업 중에는 제외)
  if (currentState != STATE_GOING_HOME_LOW_BATTERY &&
      currentState != STATE_GOING_HOME_TRASH_FULL &&
      currentState != STATE_AT_HOME &&
      currentState != STATE_STOPPED_OBSTACLE_DETECTED &&
      currentState != STATE_RFID_DETECTED &&
      currentState != STATE_MEASURING_WEIGHT_BEFORE &&
      currentState != STATE_OPENING_LID &&
      currentState != STATE_LID_OPEN_WAITING &&
      currentState != STATE_CLOSING_LID &&
      currentState != STATE_MEASURING_WEIGHT_AFTER &&
      currentState != STATE_CALCULATING_AND_SENDING ) {
    if (isBatteryLow()) {
        Serial.println("배터리 부족 감지! 지정 위치로 복귀합니다.");
        stopMotors();
        transitionTo(STATE_GOING_HOME_LOW_BATTERY);
    }
  }

  switch (currentState) {
    case STATE_LINE_FOLLOWING: {
      long distance = measureDistance();
      if (distance <= obstacle_distance_threshold) {
        Serial.println("장애물 감지! 정지 후 RFID 대기.");
        stopMotors();
        transitionTo(STATE_STOPPED_OBSTACLE_DETECTED);
      } else {
        int left_sensor_val = analogRead(LINE_SENSOR_LEFT);
        int right_sensor_val = analogRead(LINE_SENSOR_RIGHT);
        updateLineFollowing(left_sensor_val, right_sensor_val);
      }
      break;
    }

    case STATE_STOPPED_OBSTACLE_DETECTED: {
      if (readRFID()) {
        Serial.println("RFID 카드 감지됨!");
        transitionTo(STATE_RFID_DETECTED);
      }
      break;
    }

    case STATE_STOPPED_WAITING_RFID: {
        break;
    }

    case STATE_RFID_DETECTED: {
        Serial.print("감지된 RFID UID: "); Serial.println(current_rfid_uid_str);
        mfrc522.PICC_HaltA();
        mfrc522.PCD_StopCrypto1(0);
        transitionTo(STATE_MEASURING_WEIGHT_BEFORE);
        break;
    }

    case STATE_MEASURING_WEIGHT_BEFORE: {
        Serial.println("쓰레기 넣기 전 무게 측정 중...");
        stopMotors();
        if (millis() - state_timer < WEIGHT_STABILIZE_DURATION) {
            Serial.print(".");
            delay(100);
        } else {
            initial_weight = readStableWeight();
            Serial.print("초기 무게: "); Serial.print(initial_weight); Serial.println(" g");
            transitionTo(STATE_OPENING_LID);
        }
        break;
    }

    case STATE_OPENING_LID: {
      Serial.println("뚜껑 열기...");
      openLid();
      lid_open_timer = millis();
      transitionTo(STATE_LID_OPEN_WAITING);
      break;
    }

    case STATE_LID_OPEN_WAITING: {
      if (millis() - lid_open_timer >= LID_OPEN_DURATION) {
        Serial.println("5초 경과. 뚜껑 닫기.");
        transitionTo(STATE_CLOSING_LID);
      }
      break;
    }

    case STATE_CLOSING_LID: {
      Serial.println("뚜껑 닫기...");
      closeLid();
      delay(1000); // 서보 닫힘 시간 대기
      transitionTo(STATE_MEASURING_WEIGHT_AFTER);
      break;
    }

    case STATE_MEASURING_WEIGHT_AFTER: {
        Serial.println("쓰레기 넣은 후 무게 측정 중...");
        stopMotors();
        if (millis() - state_timer < WEIGHT_STABILIZE_DURATION) {
             Serial.print(".");
             delay(100);
        } else {
            final_weight = readStableWeight();
            Serial.print("최종 무게: "); Serial.print(final_weight); Serial.println(" g");
            transitionTo(STATE_CALCULATING_AND_SENDING);
        }
      break;
    }

    case STATE_CALCULATING_AND_SENDING: {
      trash_weight = final_weight - initial_weight;
      if (trash_weight < 0) {
         trash_weight = 0;
         Serial.println("경고: 계산된 무게가 음수입니다. 0으로 처리합니다.");
      }
      Serial.print("계산된 쓰레기 무게: "); Serial.print(trash_weight); Serial.println(" g");
      Serial.print("ThingSpeak로 데이터 전송 시도 - RFID UID: "); Serial.println(current_rfid_uid_str);

      unsigned long rfid_numeric_id = getRFIDasULong(current_rfid_uid_bytes, current_rfid_uid_size);
      Serial.print("ThingSpeak 전송용 RFID 숫자 ID: "); Serial.println(rfid_numeric_id);
      ThingSpeak.setField(TS_FIELD_RFID, rfid_numeric_id);
      ThingSpeak.setField(TS_FIELD_WEIGHT, trash_weight);

      int httpCode = ThingSpeak.writeFields(myChannelNumber, myWriteAPIKey);
      if (httpCode == 200) {
        Serial.println("ThingSpeak 업데이트 성공.");
      } else {
        Serial.print("ThingSpeak 업데이트 실패. HTTP 에러 코드: "); Serial.println(httpCode);
      }
      current_rfid_uid_str = "";
      current_rfid_uid_size = 0;

      if (trash_weight >= MAX_TRASH_WEIGHT_THRESHOLD) {
        Serial.print("쓰레기 무게 ("); Serial.print(trash_weight);
        Serial.println("g)가 기준치를 초과했습니다. 지정 위치로 복귀합니다.");
        transitionTo(STATE_GOING_HOME_TRASH_FULL);
      } else {
        transitionTo(STATE_RESUMING_MOVEMENT);
      }
      break;
    }

    case STATE_RESUMING_MOVEMENT: {
        Serial.println("라인 추적 움직임 재개.");
        transitionTo(STATE_LINE_FOLLOWING);
        break;
    }

    case STATE_GOING_HOME_TRASH_FULL:
    case STATE_GOING_HOME_LOW_BATTERY: {
      Serial.print("지정 위치로 복귀 중. 원인: ");
      if (currentState == STATE_GOING_HOME_TRASH_FULL) Serial.println("쓰레기 초과");
      else Serial.println("배터리 부족");

      int left_sensor_val = analogRead(LINE_SENSOR_LEFT);
      int right_sensor_val = analogRead(LINE_SENSOR_RIGHT);
      bool left_on_line = left_sensor_val < line_threshold;
      bool right_on_line = right_sensor_val < line_threshold;

      if (left_on_line && right_on_line) { // 홈 위치 조건
        Serial.println("지정 위치(홈) 감지! 정지합니다.");
        stopMotors();
        transitionTo(STATE_AT_HOME);
      } else {
        updateLineFollowing(left_sensor_val, right_sensor_val);
      }
      break;
    }

    case STATE_AT_HOME: {
      Serial.println("지정 위치(홈)에 도착하여 대기 중입니다.");
      stopMotors();
      // 추가 로직 필요 (예: 쓰레기 비움/충전 완료 감지 후 재시작)
      delay(2000); // 루프 과부하 방지
      break;
    }
  }
  // delay(10); // 루프 지연 (필요시)
}

// ==== 헬퍼 함수 구현 ====

void stopMotors() {
  digitalWrite(MOTOR_LEFT_IA, LOW);
  digitalWrite(MOTOR_LEFT_IB, LOW);
  digitalWrite(MOTOR_RIGHT_IA, LOW);
  digitalWrite(MOTOR_RIGHT_IB, LOW);
}

void moveForward(int speed) {
  analogWrite(MOTOR_LEFT_IA, speed);
  digitalWrite(MOTOR_LEFT_IB, LOW);
  analogWrite(MOTOR_RIGHT_IA, speed);
  digitalWrite(MOTOR_RIGHT_IB, LOW);
}

void turnLeft(int speed) { // 오른쪽 전진, 왼쪽 후진
  digitalWrite(MOTOR_LEFT_IA, LOW);
  analogWrite(MOTOR_LEFT_IB, speed);
  analogWrite(MOTOR_RIGHT_IA, speed);
  digitalWrite(MOTOR_RIGHT_IB, LOW);
}

void turnRight(int speed) { // 왼쪽 전진, 오른쪽 후진
  analogWrite(MOTOR_LEFT_IA, speed);
  digitalWrite(MOTOR_LEFT_IB, LOW);
  digitalWrite(MOTOR_RIGHT_IA, LOW);
  analogWrite(MOTOR_RIGHT_IB, speed);
}

long measureDistance() {
  return ultrasonic.read();
}

void updateLineFollowing(int left_sensor_val, int right_sensor_val) {
    int base_speed = 150;
    int turn_speed = 180;

    bool left_on_line = left_sensor_val < line_threshold;
    bool right_on_line = right_sensor_val < line_threshold;

    if (left_on_line && right_on_line) {
        moveForward(base_speed);
    } else if (!left_on_line && right_on_line) {
        turnLeft(turn_speed);
    } else if (left_on_line && !right_on_line) {
        turnRight(turn_speed);
    } else {
        Serial.println("라인 이탈 감지: 정지");
        stopMotors();
    }
}

void openLid() {
  lidServo.write(lid_open_angle);
}

void closeLid() {
  lidServo.write(lid_closed_angle);
}

float readStableWeight() {
    int num_readings = 10;
    float sum = 0;
    int stable_readings_count = 0;

    for (int i = 0; i < num_readings; i++) {
        if (scale.wait_ready_timeout(1000)) {
           sum += scale.get_units();
           stable_readings_count++;
           delay(50);
        } else {
            Serial.println("경고: HX711 준비 안됨!");
        }
    }
    if (stable_readings_count > 0) {
      return sum / stable_readings_count;
    } else {
      Serial.println("오류: 무게를 읽을 수 없습니다.");
      return 0.0;
    }
}

void connectWiFi() {
  Serial.print("Wi-Fi 연결 중");
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nWi-Fi 연결 성공!");
  Serial.print("IP 주소: "); Serial.println(WiFi.localIP());
}

bool readRFID() {
  if (mfrc522.PICC_IsNewCardPresent()) {
    if (mfrc522.PICC_ReadCardSerial()) {
      current_rfid_uid_str = "";
      for (byte i = 0; i < mfrc522.uid.size; i++) {
        current_rfid_uid_str += (mfrc522.uid.uidByte[i] < 0x10 ? "0" : "");
        current_rfid_uid_str += String(mfrc522.uid.uidByte[i], HEX);
      }
      current_rfid_uid_str.toUpperCase();
      for (byte i = 0; i < mfrc522.uid.size; i++) {
         current_rfid_uid_bytes[i] = mfrc522.uid.uidByte[i];
      }
      current_rfid_uid_size = mfrc522.uid.size;
      Serial.print("카드 UID (Hex): "); Serial.println(current_rfid_uid_str);
      return true;
    }
  }
  return false;
}

// RFID UID 바이트 배열을 Unsigned Long 숫자로 변환 (Big-endian 방식)
unsigned long getRFIDasULong(byte* uid, byte uidSize) {
    unsigned long number = 0;
    int bytes_to_use = min((int)uidSize, 4); // ULong은 4바이트, UID의 앞부분 사용
    for (int i = 0; i < bytes_to_use; i++) {
        number = (number << 8) | uid[i];
    }
    return number;
}

// 배터리 전압 확인 함수
bool isBatteryLow() {
  // ADC 감쇠 설정 (매번 호출하는 것보다 setup에서 한 번 설정하는 것이 효율적일 수 있음)
  // analogSetPinAttenuation(BATTERY_VOLTAGE_PIN, ADC_11DB); // ESP32 IDF 스타일
  // Arduino ESP32에서는 setup에서 미리 adcAttachPin(BATTERY_VOLTAGE_PIN) 후 analogRead 사용 권장

  int adc_value = analogRead(BATTERY_VOLTAGE_PIN);

  // 실제 전압 계산 (디버깅 및 참고용)
  // ESP32 ADC의 정확한 기준 전압 및 특성을 고려해야 함 (Vref 보통 1.1V 내부, 감쇠 후 스케일링)
  // 11dB 감쇠 시, 대략 0 ~ 3.1V (또는 3.3V) 범위가 0-4095로 매핑됨
  float voltage_at_adc_pin = adc_value * (3.3 / 4095.0); // 3.3V가 ADC 최대치라고 가정
  float actual_battery_voltage = voltage_at_adc_pin * (R1_VALUE + R2_VALUE) / R2_VALUE;

  Serial.print("Battery ADC Raw: "); Serial.print(adc_value);
  Serial.print(", ADC Pin Volt: ~"); Serial.print(voltage_at_adc_pin, 2); Serial.print("V");
  Serial.print(", Est. Battery Volt: ~"); Serial.print(actual_battery_voltage, 2); Serial.println("V");

  if (adc_value < LOW_BATTERY_ADC_THRESHOLD) {
    return true;
  }
  return false;
}

// 시스템 상태 전환 함수
void transitionTo(SystemState nextState) {
  currentState = nextState;
  state_timer = millis();
  Serial.print("--- 상태 전환: ");
  switch (currentState) {
    case STATE_LINE_FOLLOWING: Serial.println("라인 추적"); break;
    case STATE_STOPPED_OBSTACLE_DETECTED: Serial.println("장애물 감지, 정지"); break;
    case STATE_STOPPED_WAITING_RFID: Serial.println("정지, RFID 대기"); break;
    case STATE_RFID_DETECTED: Serial.println("RFID 감지됨"); break;
    case STATE_MEASURING_WEIGHT_BEFORE: Serial.println("무게 측정 (투입 전)"); break;
    case STATE_OPENING_LID: Serial.println("뚜껑 열기"); break;
    case STATE_LID_OPEN_WAITING: Serial.println("뚜껑 열림 대기"); break;
    case STATE_CLOSING_LID: Serial.println("뚜껑 닫기"); break;
    case STATE_MEASURING_WEIGHT_AFTER: Serial.println("무게 측정 (투입 후)"); break;
    case STATE_CALCULATING_AND_SENDING: Serial.println("무게 계산 및 전송"); break;
    case STATE_RESUMING_MOVEMENT: Serial.println("움직임 재개"); break;
    case STATE_GOING_HOME_TRASH_FULL: Serial.println("지정 위치로 복귀 (쓰레기 초과)"); break;
    case STATE_GOING_HOME_LOW_BATTERY: Serial.println("지정 위치로 복귀 (배터리 부족)"); break;
    case STATE_AT_HOME: Serial.println("지정 위치(홈) 대기 중"); break;
    default: Serial.println("알 수 없는 상태"); break;
  }
}