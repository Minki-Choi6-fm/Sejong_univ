#pragma warning(disable:4996)
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>                //헤더 선언
#define MAX 101

typedef struct Node{                //Node 구조체
    int id;
    int data;
    struct Node *left;
    struct Node *right;
}Node;                              //트리 구축

Node *tree;                         //트리 선언

void createTree(void){              //createTree 함수
    Node *F8=(Node*)malloc(sizeof(Node));
    Node *F7=(Node*)malloc(sizeof(Node));
    Node *F6=(Node*)malloc(sizeof(Node));
    Node *F5=(Node*)malloc(sizeof(Node));
    Node *F4=(Node*)malloc(sizeof(Node));
    Node *F3=(Node*)malloc(sizeof(Node));
    Node *F2=(Node*)malloc(sizeof(Node));
    Node *F1=(Node*)malloc(sizeof(Node));       //트리 노드 선언
    
    F8->id=8;
    F8->data=80;
    F8->left=NULL;
    F8->right=NULL;
    
    F7->id=7;
    F7->data=130;
    F7->left=NULL;
    F7->right=NULL;
    
    
    F5->id=5;
    F5->data=90;
    F5->left=NULL;
    F5->right=NULL;
    
    F4->id=4;
    F4->data=70;
    F4->left=NULL;
    F4->right=NULL;
    
    F6->id=6;
    F6->data=120;
    F6->left=F7;
    F6->right=F8;

    F3->id=3;
    F3->data=50;
    F3->left=NULL;
    F3->right=F6;
    
    F2->id=2;
    F2->data=30;
    F2->left=F4;
    F2->right=F5;
    
    F1->id=1;
    F1->data=20;
    F1->left=F2;
    F1->right=F3;                       //노드 선언
    
    tree=F1;
}                                       //트리 구축

Node *findnode(Node *node,int M){       //findNode 함수
    if(node==NULL){
        return NULL;
    }                                   //base case
    if(node->id==M){
        return node;                    //찾는 id면 그 노드 반환
    }
    Node *foundNode = findnode(node->left, M);
    if (foundNode != NULL) {
        return foundNode;
    }
    return findnode(node->right, M);    //recursion case
}

void preorder(Node *node){              //선위순회 함수
    if (node == NULL) return;           //base case
    printf("%d ",node->data);           //출력
    if(node->left!=NULL)preorder(node->left);
    if(node->right!=NULL)preorder(node->right); //recursion case
}
void postorder(Node *node){             //후위순회 함수
    if (node == NULL) return;           //base case
    if(node->left!=NULL)postorder(node->left);
    if(node->right!=NULL)postorder(node->right);//recursion case
    printf("%d ",node->data);           //출력
}
void inorder(Node *node){               //중위순회 함수
    if (node == NULL) return;           //base case
    if(node->left!=NULL)inorder(node->left);
    printf("%d ",node->data);           //출력
    if(node->right!=NULL)inorder(node->right);  //recursion case
}

int main(void){                     //main 함수
    createTree();                   //트리 만들기
    int N,M;
    scanf("%d %d",&N,&M);           //입력값 받기
    
    if(N==1||N==2||N==3){           //유효한 순회 입력 받으면
        if(M<=0||M>8){              //유효한 노드가 아니면
            printf("-1");           //-1 출력
            return 0;
        }
        Node *node=tree;            //노드 초기화 뒤
        node=findnode(node,M);
        if(N==1){
            preorder(node);         //선위순회 호출
        }
        if(N==2){
            inorder(node);          //중위순회 호출
        }
        if(N==3){
            postorder(node);        //후위순회 호출
        }
    }
    
    
    return 0;                       //0 반환
}
